#!/bin/sh
# This script runs on the client to install balenaOS
#
# DRY_RUN defaults to true, and prevents any modifications from being written
# to disk. Disable this to write balenaOS for real, destroying any existing
# data in the process.
#
# CLOBBER defaults to false, and prevents existing partition tables from being
# overwritten by the installer. You probably don't want to disable this, as it
# prevents data loss in case of booting the installer on a device that's
# already been provisioned, or a device that's not intended to be installed to.
# This option can be disabled to force installation to devices with existing
# partitions and filesystems.
image_path=$1
TARGET_DISKS=${TARGET_DISKS:-nvme?n? sd? mmcblk? vd?}
INSTALL_COUNTDOWN=${INSTALL_COUNTDOWN:-10}
DRY_RUN=${DRY_RUN:-true}
CLOBBER=${CLOBBER:-false}

if ! mount -t devtmpfs none /dev; then
	echo "Failed to mount devtmpfs at /dev w/ $?"
	exit 1;
fi

if ! mount -t proc none /proc; then
	echo "Failed to mount proc at /proc w/ $?"
	exit 1;
fi

# https://patorjk.com/software/taag/#p=display&f=Big%20Money-se&t=balenaOS
cat << 'EOF'


 __                  __                                 ______    ______
|  \                |  \                               /      \  /      \
| $$____    ______  | $$  ______   _______    ______  |  $$$$$$\|  $$$$$$\
| $$    \  |      \ | $$ /      \ |       \  |      \ | $$  | $$| $$___\$$
| $$$$$$$\  \$$$$$$\| $$|  $$$$$$\| $$$$$$$\  \$$$$$$\| $$  | $$ \$$    \
| $$  | $$ /      $$| $$| $$    $$| $$  | $$ /      $$| $$  | $$ _\$$$$$$\
| $$__/ $$|  $$$$$$$| $$| $$$$$$$$| $$  | $$|  $$$$$$$| $$__/ $$|  \__| $$
| $$    $$ \$$    $$| $$ \$$     \| $$  | $$ \$$    $$ \$$    $$ \$$    $$
 \$$$$$$$   \$$$$$$$ \$$  \$$$$$$$ \$$   \$$  \$$$$$$$  \$$$$$$   \$$$$$$



EOF

for m in ${MODULES}; do
	modprobe "${m}"
done

install_disk=""
for glob in ${TARGET_DISKS}; do
	echo "Disks matching glob: ${glob}"
	for f in /dev/${glob}; do
		if [ "$f" = "/dev/${glob}" ]; then
			echo "none"
		else
			# grab the first matching disk
			[ -z "${install_disk}" ] && install_disk="$f"
			echo "$f"
		fi
	done

	printf "\n"
done

if [ -n "${install_disk}" ]; then
	msg="Installing to disk ${install_disk}"
	if [ "${DRY_RUN}" = true ]; then
		msg="${msg} [DRY RUN]"
		# Remove the device node, just to be sure we don't write to it
		rm "${install_disk}"
		[ -f "${install_disk}" ] && exit 1
		install_disk=/dev/null
	fi

	echo "${msg}"
else
	echo "No matching disk found"
	exit 1;
fi

existing_partitions=$(($(grep -c "$(basename "${install_disk}")" /proc/partitions) - 1))

if [ "${existing_partitions}" -gt 0 ] && [ "${CLOBBER}" != "true" ]; then
	echo "Disk is already partitioned, bailing out"
	exit 1;
fi

curl "${image_path}" --progress-bar | dd of="${install_disk}" bs=4096

printf "\nSyncing..." \
	&& sync \
	&& printf 'done\n\n'

if [ "${install_disk}" != /dev/null ]; then
	if [ -f /boot/config.json ]; then
		partprobe

		# Linux device names have a 'p' between the disk and partition number
		# when the last character of the disk is a digit
		last_char="$(printf '%s' ${install_disk} | tail -c 1)"
		if [ "${last_char}" -eq "${last_char}" ] 2>/dev/null; then
			partition="n1"
		else
			partition="1"
		fi

		echo "Copying config.json into boot partition"
		if ! mount "${install_disk}${partition}" /mnt; then
			echo "Unable to mount boot partition, exiting"
			exit 1;
		fi

		cp /boot/config.json /mnt/
	fi
fi

echo "Install finished, rebooting"
reboot
